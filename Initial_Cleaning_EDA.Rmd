---
title: "Final Project R Notebook"
output: html_notebook
author: "Phil Prosapio, Shayan Khan, Jiyuan Zhou"
---

#Introduction to Data Set
For our final project, our group decided to tackle the Shelter Animal Outcomes Kaggle competition (found here: https://www.kaggle.com/c/shelter-animal-outcomes/data). This data comes from the Austin Animal Center from October 1st, 2013 to March, 2016. To supplement this Kaggle dataset, we went directly to the Austin Animal Center website and downloaded a related dataset that contains intake information about the pets and merged this additional info into our overall dataset (https://data.austintexas.gov/Health-and-Community-Services/Austin-Animal-Center-Intakes/wter-evkm).Fun fact is that one of our group members actually worked at this animal center back in Austin!

This dataset contains information about cats and dogs that were sheltered at the Austin Animal Center. It contains general info about the animals like: type of animal, breed, color, age on outcome, etc.; where the outcome of interest in this competition represent the status of animals as they leave the Animal Center. We needed to merge our intake and outcome datasets and some of the data columns required cleanup or transformation to be of more use to us (e.g. splitting the Sex column into the animals Sex as well as the status of their sexual organs - neutered/intact/etc.), while others were of no value when it comes to trying to apply our models. All animals receive a unique Animal ID during intake.

Our goal is to predict the outcome of animals as they leave the animal center. The outcomes can be one of the following: Adoption, Died, Euthanasia, Return to owner, and Transfer.

The train and test data were randomly split for us already.  

It is our belief that producing an accurate and detailed model to help predict outcomes for these shelter animals could help the Austin Animal Center and the animals themselves in a couple ways:
- Help the animal center better predict the outcome of a new animal that comes into the shelter. And depending on that predicted outcome, take proactive measures to steer "assist" the animal in receiving a better outcome based on what our model tells us makes for a pet that is more likely to be adopted.
- Help the animal center better predict allocation of resources based on what actions might need to be taken for each pet in order to maximize the number of positive outcomes for the shelter animals.

## Project setup
```{r}
#Load Libraries
libraries <- c("tidyverse", "ggplot2", "DataExplorer", "gridExtra",
               "reshape", "purrr", "lubridate")

for(lb in libraries){
  # cat(paste(lb))
  if(!(require(lb, character.only = TRUE))){
    install.packages(lb)
  }

  library(lb, character.only = TRUE)
}
```

# #Helper Functions for Data Cleanup and EDA
```{r helper functions}
#Helper function to convert values in the AgeuponOutcome/Intake column from time strings (e.g. 1 year, 2 months, etc.) into time in months
timeWarp <- function(age) {
  age_elements <- str_split_fixed(age,"\\s",2)
  norm_age = as.numeric(age_elements[1])
  norm_age
  time_unit = age_elements[2]
  #Based on unit of time, appropriately scale up age variable
  if (grepl(time_unit, "(week)s?")) {
    norm_age = norm_age*7
  } else if (grepl(time_unit, "(months)s?")) {
    norm_age = norm_age*30
  } else if (grepl(time_unit, "(year)s?")) {
    norm_age = norm_age * 365
  }
  return(norm_age / 30)
}
```


## Exploratory Data Analysis of Data
Read in the data from the two different data sources we are using: the animal intake dataset and animal outtake dataset. We then apply the timeWarp function on both data sets to make their age columns into usable values.
```{r}
#Load in data and start transforming it
animal_out <- read_csv(gzfile("data/train.csv.gz")) %>% 
              select(-DateTime, -OutcomeSubtype) %>% 
              transform(SexuponOutcome = colsplit(SexuponOutcome, split = "\\s+", names = c('S_Organ_Status_Out', 'Sex_drop')))

animal_in <- read_csv("data/Austin_Animal_Center_Intakes.csv") %>% 
             select(-Name, -Breed, -Color, -`Animal Type`) %>% 
             transform(`Sex upon Intake` = colsplit(`Sex upon Intake`, split = "\\s+", names = c('S_Organ_Status_In', 'Sex')))
```

##Clean the data
Clean up and split a variety of columns to produce more usable features that can then be used in our models.
```{r}
animal_out$AgeuponOutcome <- vapply(animal_out$AgeuponOutcome, FUN = timeWarp, FUN.VALUE = double(1)) 
animal_in$AgeuponIntake <- vapply(animal_in$Age.upon.Intake, FUN = timeWarp, FUN.VALUE = double(1)) 
#Split the SexuponOutcome/Intake columns in order to get access to the pets sex as well as the status of their sexual organs (neutered, intact, etc.)
animal_out$S_Organ_Status_Out <- animal_out$SexuponOutcome$S_Organ_Status_Out
animal_out$Sex_drop <- animal_out$SexuponOutcome$Sex_drop

animal_in$S_Organ_Status_In <- animal_in$Sex.upon.Intake$S_Organ_Status_In
animal_in$Sex <- animal_in$Sex.upon.Intake$Sex

#Convert Name column into factor so we can see if the fact that the pet had a name documented affected it's outcome. 1=Had Name, 0=Name Unknown
animal_out$Name[!is.na(animal_out$Name)] <- 1
animal_out$Name[is.na(animal_out$Name)] <- 0
animal_out$Name <- as.factor(animal_out$Name)

#Final steps of cleaning up my data and then merging it together.
animal_out <- animal_out %>% #cad standing for Cleaned_Animal_Data
       select(-SexuponOutcome, -Sex_drop) %>% 
       na.omit()

animal_in <- animal_in %>% 
             select(-Sex.upon.Intake, -Age.upon.Intake)

#Inner join to combine data from the intake and outcome data frames and merge each row based on the unique Animal ID.
a_merged <- inner_join(animal_out, animal_in, by = c("AnimalID" = "Animal.ID"), all.x=TRUE) %>% 
                   filter(AgeuponIntake <= AgeuponOutcome)

#Save off a non-dummified column for use in EDA
plot_data <- a_merged %>%
             select(-AnimalID)
```

```{r Initial view of data}
glimpse(a_merged)
```

There are 1380 unique breeds in the dataset. This is far too many
```{r}
length(unique(a_merged$Breed))
```

## Feature Engineering
First we need to clean the dataset to move "mix" into its own feature and keep only the first breed mentioned for the breed mixes
```{r Breed_Features}
a_merged <- a_merged %>%
  mutate(mix = ifelse(grepl("mix", Breed, ignore.case = T), 1, 0),
         breed_new = gsub(" Mix", "", Breed),
         breed_new = strsplit(x = breed_new, split = "/"),
         breed_new = map_chr(breed_new, function(x){unlist(x[1])}))
```

Because there are so many separate breeds and colors, it would be difficult to includee them in our model. For this reason, we'll categorize them for analysis.

It does look like there are a number of popular breeds that take up more than 75% of the dataset:
```{r}
popular <- a_merged %>%
  count(breed_new, sort = TRUE) %>%
  mutate(freq = round(100 * n / sum(n),2)) %>%
  mutate(cumfreq = cumsum(freq)) %>%
  mutate(is_pop = ifelse(cumfreq < 75, 1, 0))

popular %>%
  head(20)
```
For dogs, the most common breeds are Pit Bulls, Chihuahuas, and Labs.
```{r}
dog_popular <- a_merged %>%
  filter(AnimalType == 'Dog') %>%
  count(breed_new, sort = TRUE) %>%
  mutate(freq = round(100 * n / sum(n),2)) %>%
  head(16)

print(dog_popular)
```
80% of Cat breeds appear to be Domestic Shorthair.
```{r}
cat_popular <- a_merged %>%
  filter(AnimalType == 'Cat') %>%
  count(breed_new, sort = TRUE) %>%
  mutate(freq = round(100 * n / sum(n),2)) %>%
  head(16)

print(cat_popular)
```

```{r}
popular %>%
  filter(is_pop == 1) %>%
  select(breed_new) -> common

a_merged <- a_merged %>%
  mutate(breed_common = ifelse(breed_new %in% common$breed_new, 1, 0))
```
We've now grouped the 1365 sparse class breeds into one "Uncommon" group.

```{r}
breed_groups <- read.csv("breedGroups.csv")
names(breed_groups) <- c("breed_new", "breed_group")
#color_groups <- read.csv("colorGroups.csv", row.names = NULL)

a_merged <- inner_join(a_merged, breed_groups, by = "breed_new")
#a_merged <- left_join(a_merged, color_groups, by = c("Color" = "colors"))
```

#Save off data frame for use at later points
```{r}
write.csv(a_merged, file="Data/Cleaned_Data_Frame.csv")
```

```{r fig.width=10, fig.height=10}
a_merged %>%
    plot_bar(title = "Bar plots of cleaned data")
```

```{r}
glimpse(plot_data)
```

```{r}
glimpse(a_merged)
```

```{r fig.width=10, fig.height=10}
g <- ggplot(data=a_merged, aes(x=breed_group, fill= OutcomeType )) 
g + geom_bar(stat="count", position=position_dodge()) +
    xlab("Whether a cat is over average heart weight") +
    ylim(0, 800) + 
    ggtitle("Gender distribution on over and below average heart weight group.") +
    facet_grid(~ OutcomeType)
```

```{r}
g <- ggplot(data=plot_data, aes(x=AnimalType, fill= OutcomeType )) 
g + geom_bar(stat="count", position=position_dodge()) +
    xlab("Whether a cat is over average heart weight") +
    ggtitle("Gender distributin on over and below average heart weight group.") +
    facet_grid(~ OutcomeType)
```

```{r}
g <- ggplot(data=plot_data, aes(x=Name, fill= OutcomeType )) 
g + geom_bar(stat="count", position=position_dodge()) +
    xlab("Whether a cat is over average heart weight") +
    ggtitle("Gender distributin on over and below average heart weight group.") +
    facet_grid(~ OutcomeType)
```

```{r}
g <- ggplot(data=plot_data, aes(x=S_Organ_Status_Out, fill= OutcomeType )) 
g + geom_bar(stat="count", position=position_dodge()) +
    xlab("Whether a cat is over average heart weight") +
    ggtitle("Gender distributin on over and below average heart weight group.") +
    facet_grid(~ OutcomeType)
```
```{r}
g <- ggplot(data=plot_data, aes(x=AgeuponOutcome, fill= OutcomeType )) 
g + geom_bar(stat="bin", position=position_dodge()) +
    xlab("Whether a cat is over average heart weight") +
    ggtitle("Gender distributin on over and below average heart weight group.") +
    facet_grid(~ OutcomeType)
```


***Ending blurb about data cleaning and EDA




